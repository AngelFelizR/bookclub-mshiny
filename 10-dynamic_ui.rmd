# Dynamic UI

**Learning objectives:**

Learn how to **add dynamics to a Shiny app**

Introduction

1 - Updating inputs

2 - Dynamic visibility

3 - Creating UI with code

Conclusions


## Introduction 

This chapter is based on Dynamic UI

What is a dynamic user interface?

How to create dynamic user interfaces, changing the UI using code run in the server function,by modifying inputs and outputs.

## First

### Three key techniques for creating dynamic user interface:

```{r libraries, message=FALSE, warning=FALSE, include=FALSE}
library(shiny)
library(dplyr, warn.conflicts = FALSE)
library(DiagrammeR)
```

---------------------------------------

1 - update functions

2 - tabsetPanel()

3 - uiOutput() and renderUI()

-------------------------------------------

Basic structure Example: 

```{r echo=FALSE}
mermaid("
graph LR 
A[User Interface]-->B[Server]
")
```


User Interface and Server basic structure:
```{r}
# ui <- fluidPage(
  
#  [id]Input(),
  
#  actionButton()
# )

# server <- function(input, output, session) {
  
#  observeEvent(input$... , {
    
#    update[id]Input(inputId = ... , ... = input$... )
#  })  
#  ...
# }
```



-----------------------------------------

### Updating

#### 1 - update functions

```{r , echo=FALSE}
mermaid("
graph LR
A[id Input]-->B[update id Input]
")
```


It allows you to modify the control after it has been created
```{r}
# [id]Input()
# textInput() # ui
# update [....] Input()
# updateTextInput() # server

# numericInput()
# update [....] Input()
# updateNumericInput()

#-------------------------------------
# selectInput()
# update [....] Input()
# updateSelectInput()

# sliderInput()
# update [....] Input()
# updateSliderInput()
```

- Hierarchical, Freezing and Circular references

The selection of natural hierarchy in the data to create a user interface that allows you to update the input dynamically generated across multiple categories, let's you establish priorities and provides with key features such as "freezing Reactive Inputs" to visually summarize your data. 

The circularity is seen in apps where updating the input, automatically another input is created in function of the first one. In this cases the cycle can create an infinite loop on the current value of an input bringing it to run again and again in circularity.

```{r}
# [id]Input()
# tableOutput()

# observeEvent()
# update[id]Input() 
```


The function - update[id]Input() - only has an affect after all outputs and observers have run, for this reason the freezing function would let you hierarchically updating all your inputs before displaying it.

```{r}
# [id]Input()
# [some]Output()

# observeEvent()
# freezeReactiveValue() “freezing” the input
# update[id]Input() 
```

##### How the "Action button" reset the "input"

- Reset button

to make it easy to reset parameters back to their initial value (first simple example)

```{r}
# [id]Input()
# actionButton()

# observeEvent()
# update[id]Input()


# [id]Input()
# actionButton()

# observeEvent()
# updateActionButton()
```

A simple use of the "reset" input button is shown in this example: 

Spring temperature generally lasts on average between 19 and 25 C° degree, let's set and average value of 21 C° as "reset" point.

```{r}
ui <- fluidPage(
  sliderInput("temperature", "Spring temperature", 21, min = 19, max = 25),
  actionButton("reset", "Reset")
)

server <- function(input, output, session) {
  observeEvent(input$reset,{
    updateSliderInput(inputId = "temperature", value = 21)
  })
}
```


## Second

### To show and hide parts of the UI


-----------------------------------------------

### Dynamic visibility

#### 2 - tabsetPanel()

This second section of the Dynamic uses the - tabsetPanel() - function to show and hide some of the tabs set in the main panel of the app. It is a technique allows you to manage the appearance of your app with selecting visibility of the tabs as shown in - [Tabsets](https://shiny.rstudio.com/articles/layout-guide.html) section of the Shiny.rstudio.com guide website.

```{r echo=FALSE}
mermaid("
graph LR 
A[tabsetPanel]-->B[updateTabsetPanel]
")
```

In addition to {shiny} package you can use:
```{r message=FALSE, warning=FALSE}
library(shinyWidgets)
library(shinydashboard)
library(shinythemes)
```

to enhance you app with features and the most wanted themes.

As an example on how to set the visibility of a tab in your app, you can follow the steps of this example:  [Gallery](https://shiny.rstudio.com/gallery/tabsets.html)

```{r}
library(shiny)

##################  USER INTERFACE ##############################
ui <- fluidPage(
  # Panel title
  titlePanel("App Statistics"),
  sidebarLayout(
    sidebarPanel(
      selectInput("controller", "Show", choices = c("summary","plot")),
      radioButtons("dist", "Distribution type:",
                   c("Normal" = "norm",
                     "Uniform" = "unif",
                     "Log-normal" = "lnorm",
                     "Exponential" = "exp")),

      br(), # to add vertical spacing
      sliderInput("n",
                  "Number of observations:",
                  value = 500,
                  min = 1,
                  max = 1000)
    ),

    mainPanel(
      # The "tabsetPanel()" sets the tabs, the titles and the output 
      tabsetPanel(
        id="switcher",
        type = "hidden",
        tabPanel("Plot", plotOutput("plot")),
        tabPanel("Summary", verbatimTextOutput("summary"))
      )
    )
  )
)



################# SERVER #######################################

server <- function(input, output,session) {
  observeEvent(input$controller, {
    updateTabsetPanel(inputId = "switcher", selected = input$controller)
    
  d <- reactive({
    dist <- switch(input$dist,
                   norm = rnorm,
                   unif = runif,
                   lnorm = rlnorm,
                   exp = rexp,
                   rnorm)

    dist(input$n)
  })
  })
  
  output$plot <- renderPlot({
    dist <- input$dist
    n <- input$n

    hist(d(),
         main = paste("r", dist, "(", n, ")", sep = ""),
         col = "navy", border = "white")
  })
  output$summary <- renderPrint({
    summary(d())
  })
}

```



The Conditional UI allows you to simulate different parameters to be set in the app. The - tabsetPanel() - is update with input requests as a separate section with different types of [id]Input() and then embedded inside a fuller UI.

The Wizard interface allows you to spread collected information across multiple pages with the - switch_page() - command. This also can be automatized and it will be shown in Section 19.

```{r}

```


## Third

### Modify the user interface while the app is running

------------------------------------------------

### Creating UI with code

#### 3 - uiOutput() and renderUI()

The technique of Creating UI with code gives the developer the ability to create and modify the user interface while the app is running with two functions:

- uiOutput() in the UI part of the app 
- renderUI() in the server 


Multiple controls

Dynamic filtering

Dialog boxes

Summary























